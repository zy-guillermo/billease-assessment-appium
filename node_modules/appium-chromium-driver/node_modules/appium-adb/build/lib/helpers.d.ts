/**
 * Retrieves the actual path to SDK root folder from the system environment
 *
 * @return {string|undefined} The full path to the SDK root folder
 */
export function getSdkRootFromEnv(): string | undefined;
/**
 * Retrieves the actual path to SDK root folder
 *
 * @param {string?} [customRoot]
 * @return {Promise<string>} The full path to the SDK root folder
 * @throws {Error} If either the corresponding env variable is unset or is
 * pointing to an invalid file system entry
 */
export function requireSdkRoot(customRoot?: string | null): Promise<string>;
/**
 * Retrieve the path to the recent installed Android platform.
 *
 * @param {string} sdkRoot
 * @return {Promise<import('./tools/types').PlatformInfo>} The resulting path to the newest installed platform.
 */
export function getAndroidPlatformAndPath(sdkRoot: string): Promise<import("./tools/types").PlatformInfo>;
/**
 * @param {string} zipPath
 * @param {string} dstRoot
 */
export function unzipFile(zipPath: string, dstRoot?: string): Promise<void>;
/**
 * Unsigns the given apk by removing the
 * META-INF folder recursively from the archive.
 * !!! The function overwrites the given apk after successful unsigning !!!
 *
 * @param {string} apkPath The path to the apk
 * @returns {Promise<boolean>} `true` if the apk has been successfully
 * unsigned and overwritten
 * @throws {Error} if there was an error during the unsign operation
 */
export function unsignApk(apkPath: string): Promise<boolean>;
/**
 * @param {string} stdout
 * @returns {string[]}
 */
export function getIMEListFromOutput(stdout: string): string[];
/**
 * Get the absolute path to apksigner tool
 *
 * @param {Object} sysHelpers - An instance containing systemCallMethods helper methods
 * @returns {Promise<string>} An absolute path to apksigner tool.
 * @throws {Error} If the tool is not present on the local file system.
 */
export function getApksignerForOs(sysHelpers: any): Promise<string>;
/**
 * Get the absolute path to apkanalyzer tool.
 * https://developer.android.com/studio/command-line/apkanalyzer.html
 *
 * @param {Object} sysHelpers - An instance containing systemCallMethods helper methods
 * @returns {Promise<string>} An absolute path to apkanalyzer tool.
 * @throws {Error} If the tool is not present on the local file system.
 */
export function getApkanalyzerForOs(sysHelpers: any): Promise<string>;
/**
 * Checks screenState has SCREEN_STATE_OFF in dumpsys output to determine
 * possible lock screen.
 *
 * @param {string} dumpsys - The output of dumpsys window command.
 * @return {boolean} True if lock screen is showing.
 */
export function isScreenStateOff(dumpsys: string): boolean;
/**
 * Checks mShowingLockscreen or mDreamingLockscreen in dumpsys output to determine
 * if lock screen is showing
 *
 * A note: `adb shell dumpsys trust` performs better while detecting the locked screen state
 * in comparison to `adb dumpsys window` output parsing.
 * But the trust command does not work for `Swipe` unlock pattern.
 *
 * In some Android devices (Probably around Android 10+), `mShowingLockscreen` and `mDreamingLockscreen`
 * do not work to detect lock status. Instead, keyguard preferences helps to detect the lock condition.
 * Some devices such as Android TV do not have keyguard, so we should keep
 * screen condition as this primary method.
 *
 * @param {string} dumpsys - The output of dumpsys window command.
 * @return {boolean} True if lock screen is showing.
 */
export function isShowingLockscreen(dumpsys: string): boolean;
/**
 * Check the current device power state to determine if it is locked
 *
 * @param {string} dumpsys The `adb shell dumpsys power` output
 * @returns {boolean} True if lock screen is shown
 */
export function isInDozingMode(dumpsys: string): boolean;
export function isCurrentFocusOnKeyguard(dumpsys: any): boolean;
export function getSurfaceOrientation(dumpsys: any): number | null;
export function isScreenOnFully(dumpsys: any): boolean;
/**
 * Builds command line representation for the given
 * application startup options
 *
 * @param {StartCmdOptions} startAppOptions - Application options mapping
 * @param {number} apiLevel - The actual OS API level
 * @returns {string[]} The actual command line array
 */
export function buildStartCmd(startAppOptions: StartCmdOptions, apiLevel: number): string[];
/**
 * Transforms given options into the list of `adb install.install-multiple` command arguments
 *
 * @param {number} apiLevel - The current API level
 * @param {InstallOptions} [options={}] - The options mapping to transform
 * @returns {string[]} The array of arguments
 */
export function buildInstallArgs(apiLevel: number, options?: InstallOptions): string[];
/**
 * Parses apk strings from aapt tool output
 *
 * @param {string} rawOutput The actual tool output
 * @param {string} configMarker The config marker. Usually
 * a language abbreviation or `(default)`
 * @returns {Object} Strings ids to values mapping. Plural
 * values are represented as arrays. If no config found for the
 * given marker then an empty mapping is returned.
 */
export function parseAaptStrings(rawOutput: string, configMarker: string): any;
/**
 * Parses apk strings from aapt2 tool output
 *
 * @param {string} rawOutput The actual tool output
 * @param {string} configMarker The config marker. Usually
 * a language abbreviation or an empty string for the default one
 * @returns {Object} Strings ids to values mapping. Plural
 * values are represented as arrays. If no config found for the
 * given marker then an empty mapping is returned.
 */
export function parseAapt2Strings(rawOutput: string, configMarker: string): any;
/**
 * Formats the config marker, which is then passed to parse.. methods
 * to make it compatible with resource formats generated by aapt(2) tool
 *
 * @param {Function} configsGetter The function whose result is a list
 * of apk configs
 * @param {string?} desiredMarker The desired config marker value
 * @param {string} defaultMarker The default config marker value
 * @return {Promise<string>} The formatted config marker
 */
export function formatConfigMarker(configsGetter: Function, desiredMarker: string | null, defaultMarker: string): Promise<string>;
/**
 * Transforms the given language and country abbreviations
 * to AVD arguments array
 *
 * @param {?string} language Language name, for example 'fr'
 * @param {?string} country Country name, for example 'CA'
 * @returns {Array<string>} The generated arguments. The
 * resulting array might be empty if both arguments are empty
 */
export function toAvdLocaleArgs(language: string | null, country: string | null): Array<string>;
/**
 * Retrieves the full path to the Android preferences root
 *
 * @returns {Promise<string?>} The full path to the folder or `null` if the folder cannot be found
 */
export function getAndroidPrefsRoot(): Promise<string | null>;
/**
 * Check if a path exists on the filesystem and is a directory
 *
 * @param {string} location The full path to the directory
 * @returns {Promise<boolean>}
 */
export function dirExists(location: string): Promise<boolean>;
/**
 * Escapes special characters in command line arguments.
 * This is needed to avoid possible issues with how system `spawn`
 * call handles them.
 * See https://discuss.appium.io/t/how-to-modify-wd-proxy-and-uiautomator2-source-code-to-support-unicode/33466
 * for more details.
 *
 * @param {string} arg Non-escaped argument string
 * @returns The escaped argument
 */
export function escapeShellArg(arg: string): string;
/**
 * Parses the name of launchable package activity
 * from dumpsys output.
 *
 * @param {string} dumpsys the actual dumpsys output
 * @returns {string[]} Either the fully qualified
 * activity name as a single list item or an empty list if nothing could be parsed.
 * In Android 6 and older there is no reliable way to determine
 * the category name for the given activity, so this API just
 * returns all activity names belonging to 'android.intent.action.MAIN'
 * with the expectation that the app manifest could be parsed next
 * in order to determine category names for these.
 */
export function parseLaunchableActivityNames(dumpsys: string): string[];
/**
 * Check if the given string is a valid component name
 *
 * @param {string} classString The string to verify
 * @return {RegExpExecArray?} The result of Regexp.exec operation
 * or _null_ if no matches are found
 */
export function matchComponentName(classString: string): RegExpExecArray | null;
/**
 * Extracts various package manifest details
 * from the given application file.
 *
 * @this {import('./adb.js').ADB}
 * @param {string} apkPath Full path to the application file.
 * @returns {Promise<import('./tools/types').ApkManifest>}
 */
export function readPackageManifest(this: import("./adb.js").ADB, apkPath: string): Promise<import("./tools/types").ApkManifest>;
export const APKS_EXTENSION: ".apks";
export const APK_EXTENSION: ".apk";
export const APK_INSTALL_TIMEOUT: 60000;
export const APKS_INSTALL_TIMEOUT: number;
export const DEFAULT_ADB_EXEC_TIMEOUT: 20000;
/**
 * Calculates the absolsute path to the given resource
 *
 * @param {string} relPath Relative path to the resource starting from the current module root
 * @returns {Promise<string>} The full path to the resource
 * @throws {Error} If the absolute resource path cannot be determined
 */
export const getResourcePath: ((relPath: any) => Promise<string>) & _.MemoizedFunction;
/** @type {() => Promise<string>} */
export const getJavaHome: () => Promise<string>;
/** @type {() => Promise<string>} */
export const getJavaForOs: () => Promise<string>;
/** @type {() => Promise<string>} */
export const getOpenSslForOs: () => Promise<string>;
/** @type {() => Promise<{major: number, minor: number, build: number}?>} */
export const getSdkToolsVersion: () => Promise<{
    major: number;
    minor: number;
    build: number;
} | null>;
/**
 * Retrieves full paths to all 'build-tools' subfolders under the particular
 * SDK root folder
 *
 * @type {(sdkRoot: string) => Promise<string[]>}
 */
export const getBuildToolsDirs: (sdkRoot: string) => Promise<string[]>;
export function extractMatchingPermissions(dumpsysOutput: string, groupNames: string[], grantedState?: boolean | null): string[];
export type InstallOptions = {
    /**
     * - Set to true in order to allow test
     *    packages installation.
     */
    allowTestPackages?: boolean | undefined;
    /**
     * - Set to true to install the app on sdcard
     *    instead of the device memory.
     */
    useSdcard?: boolean | undefined;
    /**
     * - Set to true in order to grant all the
     *    permissions requested in the application's manifest
     *    automatically after the installation is completed
     *    under Android 6+.
     */
    grantPermissions?: boolean | undefined;
    /**
     * - Set it to false if you don't want
     *    the application to be upgraded/reinstalled
     *    if it is already present on the device.
     */
    replace?: boolean | undefined;
    /**
     * - Install apks partially. It is used for 'install-multiple'.
     *   https://android.stackexchange.com/questions/111064/what-is-a-partial-application-install-via-adb
     */
    partialInstall?: boolean | undefined;
};
export type StartCmdOptions = {
    user?: string | number | undefined;
    waitForLaunch?: boolean | undefined;
    pkg?: string | undefined;
    activity?: string | undefined;
    action?: string | undefined;
    category?: string | undefined;
    stopApp?: boolean | undefined;
    flags?: string | undefined;
    optionalIntentArguments?: string | undefined;
};
import _ from 'lodash';
//# sourceMappingURL=helpers.d.ts.map